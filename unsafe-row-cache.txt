

hashtable to map row-key to row-entry
    - fixed hash table size (no re-hashing)
    - each hash-table-row consists (initially) of one block
        - Layout:
            Bytes   0..63               reserved for CAS + lock structures/operations
                         0.. 7          reference to LRU last-used hash-entry in this hash-row
                         8..15          CAS based hash-row lock
                         16..63         (CPU level page fill - intentionally left unused)
            Bytes   64..blockSize-1     references to hash-entries

hash-entry first block layout
    Bytes    0.. 7  LRU previous entry
    Bytes    8..15  LRU next entry
    Bytes   16..23  last-used timestamp
    Bytes   24..31  hash key length
    Bytes   32..39  hash value length
    Bytes   40..63  (CPU level page fill - intentionally left unused)
    ...

block layout
    Bytes    0.. 7  next block offset

fixed-block-size allocator
    - address-size=8 btyes
    - for example 2048 bytes
        2048 / 8 = 256
        64 GB cache would mean 33,554,432 2kB blocks
        to access 33,554,432 possible cache entries with max hash-entry-legnth of 32 means a hash-table of size 1,048,576
            means 1,048,576 * 2kB = 2 GB just for the hash table
        to access 33,554,432 possible cache entries with max hash-entry-legnth of 256 means a hash-table of size 131,072
            means 131,072 * 2kB = 256 MB just for the hash table


row-entry



LRU functionality
    - use more linked-lists (based on hash-key) to lower concurrency issues
    - one LRU list per hash key ?


Serializing & Deserializing just needs the total size + addresses of all blocks


Operations to allow direct I/O to (de)serialize cache contents

